"""
The ASSIN 2 Shared Task: A Quick Overview
https://link.springer.com/chapter/10.1007/978-3-030-41505-1_39

The ASSIN 2 corpus is composed of rather simple sentences. Following the 
procedures of SemEval 2014 Task 1. The training and validation data are composed, 
respectively, of 6,500 and 500 sentence pairs in Brazilian Portuguese, annotated 
for entailment and semantic similarity. Semantic similarity values range from 1 
to 5, and text entailment classes are either entailment or none. The test data 
are composed of approximately 3,000 sentence pairs with the same annotation. 
All data were manually annotated.

Homepage: "https://sites.google.com/view/assin2/"
"""
import os
import numpy as np
import json
import glob
import datasets
from sklearn.metrics import f1_score
from scipy.stats import pearsonr
from lm_eval.base import rf, Task
from ..metrics import mean

_CITATION = """
@inproceedings{real2020assin,
    title = "The assin 2 shared task: a quick overview",
    author= "Real, Livy and
        Fonseca, Erick and 
        Oliveira, Hugo Goncalo",
    booktitle = "International Conference on Computational Processing of the Portuguese Language",
    pages = "406--412",
    year = "2020,
    organization = "Springer",
}
"""

class ASSIN_RTE(Task):
    VERSION = 0
    DATASET_PATH = "assin2"
    DATASET_NAME = None

    def download(self, data_dir=None, cache_dir=None, download_mode=None):
        """ The dowloading of the dataset assin2 is not working. One possible
        alternative is using streaming mode to get DatasetIterator, and saving
        one JSON file for each dataset split.
        """
        try:
            #self.data = datasets.load_dataset(path=self.DATASET_PATH, name=self.DATASET_NAME)
            self.dataset = datasets.load_dataset(
                path=self.DATASET_PATH,
                name=self.DATASET_NAME,
                data_dir=data_dir,
                cache_dir=cache_dir,
                download_mode=download_mode
            )
        except:
            _cache_data = 'data/ASSIN2'
            self.dataset = {}
            if not os.path.exists(_cache_data):
                os.makedirs(_cache_data)

                # self.data = datasets.load_dataset(path=self.DATASET_PATH, name=self.DATASET_NAME, streaming=True)
                dataset = datasets.load_dataset(
                    path=self.DATASET_PATH,
                    name=self.DATASET_NAME,
                    data_dir=data_dir,
                    cache_dir=cache_dir,
                    download_mode=download_mode,
                    streaming=True,
                )

                for split, iterator in dataset.items():
                    self.dataset[split] = [ sample for sample in iterator ]

                    with open(os.path.join(_cache_data, split + '.json'), 'w') as f:
                        json.dump(self.dataset[split], f)            
            else:
                for fname in glob.glob(_cache_data + '/*json'):
                    with open(fname) as f:
                        split = os.path.basename(fname).split('.')[0]
                        self.dataset[split] = json.load(f)

    def has_training_docs(self):
        return True

    def has_validation_docs(self):
        return True

    def has_test_docs(self):
        return True

    def training_docs(self):
        return self.dataset["train"]

    def validation_docs(self):
        return self.dataset["validation"]

    def test_docs(self):
        return self.dataset["test"]

    def doc_to_text(self, doc):
        # source promptsource/templates/anli/templates.yaml (must be true)
        return (
            f"Dado que \"{doc['premise']}\". Portanto, deve ser verdade que "
            f"\"{doc['hypothesis']}\"? Sim ou Não?"
        )

    def doc_to_target(self, doc):
        # Sim = entailment
        # Não = none
        return " " + ["Não", "Sim"][doc['entailment_judgment']]

    def construct_requests(self, doc, ctx):
        """ Uses RequestFactory to construct Requests and returns an iterable of 
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural 
            language description, as well as the few shot examples, and the question
            part of the document for `doc`. 
        """
        ll_none, _ = rf.loglikelihood(ctx, " Não") 
        ll_entailment, _ = rf.loglikelihood(ctx, " Sim") 
        return ll_none, ll_entailment
    
    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a 
        dict where keys are the names of submetrics and values are the values of 
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        gold = doc['entailment_judgment']
        pred = np.argmax(results)
        return {
            "acc": pred == gold,
            "f1": (pred, gold),
        }

    @classmethod
    def macro_f1(cls, items):
        preds, golds = zip(*items)
        preds = np.array(preds)
        golds = np.array(golds)
        label_set = set(golds)
        macro_f1 = f1_score(golds, preds, average='macro', 
                        labels=list(label_set))
        return macro_f1

    def aggregation(self):
        """
        :returns: {str: [float] -> float}
            A dictionary where keys are the names of submetrics and values are 
            functions that aggregate a list of metrics
        """
        return {
            "acc": mean,
            "f1": self.macro_f1,
        }

    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are 
            whether a higher value of the submetric is better
        """
        return {
            "acc": True,
            "f1": True,
        }

class ASSIN_STS(Task):
    VERSION = 0
    DATASET_PATH = "assin2"
    DATASET_NAME = None

    def download(self, data_dir=None, cache_dir=None, download_mode=None):
        """ The dowloading of the dataset assin2 is not working. One possible
        alternative is using streaming mode to get DatasetIterator, and saving
        one JSON file for each dataset split.
        """
        try:
            self.dataset = datasets.load_dataset(
                path=self.DATASET_PATH,
                name=self.DATASET_NAME,
                data_dir=data_dir,
                cache_dir=cache_dir,
                download_mode=download_mode
            )
        except:
            _cache_data = 'data/ASSIN2'
            self.dataset = {}
            if not os.path.exists(_cache_data):
                os.makedirs(_cache_data)

                dataset = datasets.load_dataset(
                    path=self.DATASET_PATH,
                    name=self.DATASET_NAME,
                    data_dir=data_dir,
                    cache_dir=cache_dir,
                    download_mode=download_mode,
                    streaming=True,
                )

                for split, iterator in dataset.items():
                    self.dataset[split] = [ sample for sample in iterator ]

                    with open(os.path.join(_cache_data, split + '.json'), 'w') as f:
                        json.dump(self.dataset[split], f)            
            else:
                for fname in glob.glob(_cache_data + '/*json'):
                    with open(fname) as f:
                        split = os.path.basename(fname).split('.')[0]
                        self.dataset[split] = json.load(f)
                        
    def has_training_docs(self):
        return True

    def has_validation_docs(self):
        return True

    def has_test_docs(self):
        return True
    
    def training_docs(self):
        return self.dataset["train"]

    def validation_docs(self):
        return self.dataset["validation"]

    def test_docs(self):
        return self.dataset["test"]

    def doc_to_text(self, doc):
        # source: promptsource/templates/stsb_multi_mt/en/templates.yaml (Similarity_how)
        return (
            f"Quão similares são as sentenças \"{doc['premise']}\" "
            f"e \"{doc['hypothesis']}\"? Dê uma pontuação entre 1.0 e 5.0."
        )

    def doc_to_target(self, doc):
        return " {}".format(doc["relatedness_score"])

    def construct_requests(self, doc, ctx):
        """ Uses RequestFactory to construct Requests and returns an iterable of 
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural 
            language description, as well as the few shot examples, and the question
            part of the document for `doc`. 
        """
        continuation = rf.greedy_until(ctx, ['\n'])
        return continuation
    
    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a 
        dict where keys are the names of submetrics and values are the values of 
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        gold = doc['relatedness_score']
        pred = float(results[0])
        # print(f'gold: {gold}, pred: {pred}')
        return {
            "mse": (gold - pred)**2,
            "pearson": (pred, gold),
        }

    @classmethod
    def pearson(cls, items):
        preds, golds = zip(*items)
        preds = np.array(preds)
        golds = np.array(golds)
        pearson = pearsonr(golds, preds)[0]
        return pearson

    def aggregation(self):
        """
        :returns: {str: [float] -> float}
            A dictionary where keys are the names of submetrics and values are 
            functions that aggregate a list of metrics
        """
        return {
            "mse": mean,
            "pearson": self.pearson,
        }

    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are 
            whether a higher value of the submetric is better
        """
        return {
            "mse": False,
            "pearson": True,
        }
